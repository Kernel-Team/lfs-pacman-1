--- a/demux/demux_lavf.c	2017-09-13 03:40:14.000000000 +0200
+++ b/demux/demux_lavf.c	2017-12-14 20:57:06.779512999 +0100
@@ -244,7 +244,7 @@
 
     MP_TRACE(demuxer, "%d=mp_read(%p, %p, %d), pos: %"PRId64", eof:%d\n",
              ret, stream, buf, size, stream_tell(stream), stream->eof);
-    return ret;
+    return ret ? ret : AVERROR_EOF;
 }
 
 static int64_t mp_seek(void *opaque, int64_t pos, int whence)
--- a/DOCS/man/options.rst	2017-09-13 03:40:14.000000000 +0200
+++ b/DOCS/man/options.rst	2017-12-14 20:56:54.090404966 +0100
@@ -4635,9 +4635,10 @@
     Continue even if a software renderer is detected.
 
 ``--opengl-backend=<sys>``
-    The value ``auto`` (the default) selects the windowing backend. You can
-    also pass ``help`` to get a complete list of compiled in backends (sorted
-    by autoprobe order).
+    Specify a priority list of windowing backends to use with OpenGL. The value
+    ``auto`` (the default) automatically probes for the most suitable backend.
+    You can also pass ``help`` to get a complete list of compiled in backends
+    (sorted by autoprobe order).
 
     auto
         auto-select (default)
--- a/video/out/opengl/context.c	2017-09-13 03:40:14.000000000 +0200
+++ b/video/out/opengl/context.c	2017-12-14 20:56:54.090404966 +0100
@@ -89,6 +89,36 @@
 #endif
 };
 
+static bool get_desc(struct m_obj_desc *dst, int index)
+{
+    if (index == 0) {
+        *dst = (struct m_obj_desc) {
+            .name = "auto",
+            .description = "automatically select most suitable backend"
+        };
+        return true;
+    }
+    index--;
+    if (index >= MP_ARRAY_SIZE(backends) - 1)
+        return false;
+    const struct mpgl_driver *driver = backends[index];
+    *dst = (struct m_obj_desc) {
+        .name = driver->name,
+        .description = driver->name,
+        .priv_size = sizeof(struct mpgl_driver),
+        .p = driver,
+    };
+    return true;
+}
+
+// for backend option
+const struct m_obj_list mpgl_backend_list = {
+    .get_desc = get_desc,
+    .description = "OpenGL windowing backends",
+    .allow_trailer = true,
+    .disallow_positional_parameters = true,
+};
+
 // 0-terminated list of desktop GL versions a backend should try to
 // initialize. The first entry is the most preferred version.
 const int mpgl_preferred_gl_versions[] = {
@@ -103,7 +133,7 @@
     0
 };
 
-int mpgl_find_backend(const char *name)
+static int mpgl_find_backend(const char *name)
 {
     if (name == NULL || strcmp(name, "auto") == 0)
         return -1;
@@ -114,21 +144,6 @@
     return -2;
 }
 
-int mpgl_validate_backend_opt(struct mp_log *log, const struct m_option *opt,
-                              struct bstr name, struct bstr param)
-{
-    if (bstr_equals0(param, "help")) {
-        mp_info(log, "OpenGL windowing backends:\n");
-        mp_info(log, "    auto (autodetect)\n");
-        for (int n = 0; n < MP_ARRAY_SIZE(backends); n++)
-            mp_info(log, "    %s\n", backends[n]->name);
-        return M_OPT_EXIT;
-    }
-    char s[20];
-    snprintf(s, sizeof(s), "%.*s", BSTR_P(param));
-    return mpgl_find_backend(s) >= -1 ? 1 : M_OPT_INVALID;
-}
-
 static void *get_native_display(void *pctx, const char *name)
 {
     MPGLContext *ctx = pctx;
@@ -189,11 +204,36 @@
 
 // Create a VO window and create a GL context on it.
 //  vo_flags: passed to the backend's create window function
-MPGLContext *mpgl_init(struct vo *vo, const char *backend_name, int vo_flags)
+MPGLContext *mpgl_init(struct vo *vo, struct m_obj_settings *backend_list, int vo_flags)
 {
     MPGLContext *ctx = NULL;
-    int index = mpgl_find_backend(backend_name);
-    if (index == -1) {
+    if (backend_list && backend_list[0].name) {
+        int n;
+        for (n = 0; backend_list[n].name; n++) {
+            // Something like "--opengl-backend=name," allows fallback to autoprobing.
+            int index = mpgl_find_backend(backend_list[n].name);
+            if (index < 0 || strlen(backend_list[n].name) == 0)
+                goto autoprobe;
+            ctx = init_backend(vo, backends[index], true, vo_flags);
+            if (ctx)
+                break;
+        }
+        if (!ctx && !vo->probing) {
+            // Now try with probing off
+            for (n = 0; backend_list[n].name; n++) {
+                int index = mpgl_find_backend(backend_list[n].name);
+                ctx = init_backend(vo, backends[index], false, vo_flags);
+                if (ctx)
+                    break;
+            }
+            if (!ctx) {
+                // Backend explicitly requested, but unable to fulfill
+                return NULL;
+            }
+        }
+    }
+    if (!ctx) {
+autoprobe:
         for (int n = 0; n < MP_ARRAY_SIZE(backends); n++) {
             ctx = init_backend(vo, backends[n], true, vo_flags);
             if (ctx)
@@ -207,8 +247,6 @@
                     break;
             }
         }
-    } else if (index >= 0) {
-        ctx = init_backend(vo, backends[index], false, vo_flags);
     }
     return ctx;
 }
--- a/video/out/opengl/context.h	2017-09-13 03:40:14.000000000 +0200
+++ b/video/out/opengl/context.h	2017-12-14 20:56:54.089404957 +0100
@@ -100,17 +100,13 @@
     void *priv;
 } MPGLContext;
 
-MPGLContext *mpgl_init(struct vo *vo, const char *backend_name, int vo_flags);
+MPGLContext *mpgl_init(struct vo *vo, struct m_obj_settings *backend_list, int vo_flags);
 void mpgl_uninit(MPGLContext *ctx);
 int mpgl_reconfig_window(struct MPGLContext *ctx);
 int mpgl_control(struct MPGLContext *ctx, int *events, int request, void *arg);
 void mpgl_start_frame(struct MPGLContext *ctx);
 void mpgl_swap_buffers(struct MPGLContext *ctx);
 
-int mpgl_find_backend(const char *name);
-
-struct m_option;
-int mpgl_validate_backend_opt(struct mp_log *log, const struct m_option *opt,
-                              struct bstr name, struct bstr param);
+extern const struct m_obj_list mpgl_backend_list;
 
 #endif
--- a/video/out/vo_opengl.c	2017-09-13 03:40:14.000000000 +0200
+++ b/video/out/vo_opengl.c	2017-12-14 20:56:54.089404957 +0100
@@ -56,7 +56,7 @@
     int allow_sw;
     int swap_interval;
     int vsync_fences;
-    char *backend;
+    struct m_obj_settings *backend_list;
     int es;
     int pattern[2];
 };
@@ -386,7 +386,7 @@
     if (p->opts.allow_sw)
         vo_flags |= VOFLAG_SW;
 
-    p->glctx = mpgl_init(vo, p->opts.backend, vo_flags);
+    p->glctx = mpgl_init(vo, p->opts.backend_list, vo_flags);
     if (!p->glctx)
         goto err_out;
     p->gl = p->glctx->gl;
@@ -451,8 +451,7 @@
         OPT_FLAG("opengl-waitvsync", opts.waitvsync, 0),
         OPT_INT("opengl-swapinterval", opts.swap_interval, 0),
         OPT_FLAG("opengl-debug", opts.use_gl_debug, 0),
-        OPT_STRING_VALIDATE("opengl-backend", opts.backend, 0,
-                            mpgl_validate_backend_opt),
+        OPT_SETTINGSLIST("opengl-backend", opts.backend_list, 0, &mpgl_backend_list ),
         OPT_FLAG("opengl-sw", opts.allow_sw, 0),
         OPT_CHOICE("opengl-es", opts.es, 0, ({"no", -1}, {"auto", 0},
                                              {"yes", 1}, {"force2", 2})),
--- a/video/vaapi.c	2017-09-13 03:40:14.000000000 +0200
+++ b/video/vaapi.c	2017-12-14 20:57:17.855613522 +0100
@@ -112,9 +112,27 @@
     ctx->image_formats = formats;
 }
 
-// VA message callbacks are global and do not have a context parameter, so it's
-// impossible to know from which VADisplay they originate. Try to route them
-// to existing mpv/libmpv instances within this process.
+#if VA_CHECK_VERSION(1, 0, 0)
+static void va_message_callback(void *context, const char *msg, int mp_level)
+{
+    struct mp_vaapi_ctx *res = context;
+    mp_msg(res->log, mp_level, "libva: %s", msg);
+}
+
+static void va_error_callback(void *context, const char *msg)
+{
+    va_message_callback(context, msg, MSGL_ERR);
+}
+
+static void va_info_callback(void *context, const char *msg)
+{
+    va_message_callback(context, msg, MSGL_V);
+}
+#else
+// Pre-libva2 VA message callbacks are global and do not have a context
+// parameter, so it's impossible to know from which VADisplay they
+// originate.  Try to route them to existing mpv/libmpv instances within
+// this process.
 static pthread_mutex_t va_log_mutex = PTHREAD_MUTEX_INITIALIZER;
 static struct mp_vaapi_ctx **va_mpv_clients;
 static int num_va_mpv_clients;
@@ -149,6 +167,7 @@
 {
     va_message_callback(msg, MSGL_V);
 }
+#endif
 
 static void open_lavu_vaapi_device(struct mp_vaapi_ctx *ctx)
 {
@@ -181,6 +200,10 @@
         },
     };
 
+#if VA_CHECK_VERSION(1, 0, 0)
+    vaSetErrorCallback(display, va_error_callback, res);
+    vaSetInfoCallback(display,  va_info_callback,  res);
+#else
     pthread_mutex_lock(&va_log_mutex);
     MP_TARRAY_APPEND(NULL, va_mpv_clients, num_va_mpv_clients, res);
     pthread_mutex_unlock(&va_log_mutex);
@@ -191,6 +214,7 @@
     vaSetErrorCallback(va_error_callback);
     vaSetInfoCallback(va_info_callback);
 #endif
+#endif
 
     int major_version, minor_version;
     int status = vaInitialize(display, &major_version, &minor_version);
@@ -231,6 +255,7 @@
         if (ctx->destroy_native_ctx)
             ctx->destroy_native_ctx(ctx->native_ctx);
 
+#if !VA_CHECK_VERSION(1, 0, 0)
         pthread_mutex_lock(&va_log_mutex);
         for (int n = 0; n < num_va_mpv_clients; n++) {
             if (va_mpv_clients[n] == ctx) {
@@ -241,6 +266,7 @@
         if (num_va_mpv_clients == 0)
             TA_FREEP(&va_mpv_clients); // avoid triggering leak detectors
         pthread_mutex_unlock(&va_log_mutex);
+#endif
 
         talloc_free(ctx);
     }
